// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter, GITHUB_AUTH_HASH, GITHUB_TOKEN_SET, MockGithub, MockResponse, app, assert, db, expect, request, resetdb, skyl, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  request = require('supertest');

  EventEmitter = require('events').EventEmitter;

  _ref = require('chai'), assert = _ref.assert, expect = _ref.expect;

  app = require('../app').app;

  db = require('../db').db;

  _ref1 = require('../constants'), GITHUB_TOKEN_SET = _ref1.GITHUB_TOKEN_SET, GITHUB_AUTH_HASH = _ref1.GITHUB_AUTH_HASH;

  skyl = {
    "login": "skyl",
    "id": 61438
  };

  MockResponse = (function(_super) {
    __extends(MockResponse, _super);

    function MockResponse(statusCode, body) {
      var self;
      this.statusCode = statusCode;
      self = this;
      setTimeout(function() {
        self.emit("data", body);
        return self.emit("end");
      }, 1);
    }

    return MockResponse;

  })(EventEmitter);

  MockGithub = (function(_super) {
    __extends(MockGithub, _super);

    function MockGithub() {
      this.requestToken = __bind(this.requestToken, this);
      this.eventListeners = {};
      this.emitCounts = {};
      this.on('requestToken', this.requestToken);
      this.on('receiveAccessToken', this.receiveAccessToken);
    }

    MockGithub.prototype.requestToken = function(req, res, cb) {
      var _base;
      if ((_base = this.emitCounts)['requestToken'] == null) {
        _base['requestToken'] = 0;
      }
      this.emitCounts['requestToken']++;
      return cb(new MockResponse(200, '{"access_token": "boom"}'));
    };

    MockGithub.prototype.receiveAccessToken = function(access_token, cb) {
      var _base;
      if ((_base = this.emitCounts)['receiveAccessToken'] == null) {
        _base['receiveAccessToken'] = 0;
      }
      this.emitCounts['receiveAccessToken']++;
      db.sadd(GITHUB_TOKEN_SET, access_token);
      db.hset(GITHUB_AUTH_HASH, access_token, JSON.stringify(skyl));
      return cb('{}');
    };

    return MockGithub;

  })(EventEmitter);

  global.gh = new MockGithub;

  resetdb = function() {
    db.flushall();
    db.sadd(GITHUB_TOKEN_SET, "TESTTOKEN");
    return db.hset(GITHUB_AUTH_HASH, "TESTTOKEN", JSON.stringify(skyl));
  };

  describe('GITHUB AUTH', function() {
    resetdb();
    it('returns invalid with no token', function(done) {
      return request(app).get('/get/foobar').expect(/Invalid/).expect(403, done);
    });
    it('does not allow restricted keys', function(done) {
      request(app).get("/get/" + GITHUB_TOKEN_SET + "/").set({
        "access_token": "TESTTOKEN"
      }).expect(403);
      return request(app).get("/get/" + GITHUB_AUTH_HASH + "/").set({
        "access_token": "TESTTOKEN"
      }).expect(403, done);
    });
    it('rejects invalid token', function(done) {
      return request(app).get("/get/foobar").set({
        "access_token": "NOWAYTHISISAREALTOKEN"
      }).expect(403, done);
    });
    it('reject invalid token in querystring', function(done) {
      return request(app).get("/get/foobar?access_token=WRONGE").expect(403, done);
    });
    it('allows call with token in querystring', function(done) {
      return request(app).get("/get/baz?access_token=TESTTOKEN").expect(200, done);
    });
    it('emits events when /auth_callback/github is called', function(done) {
      return request(app).get("/auth_callback/github?code=thisisgreat").expect(200).expect("OK").end(function() {
        assert.equal(gh.emitCounts["requestToken"], 1);
        assert.equal(gh.emitCounts["receiveAccessToken"], 1);
        return db.sismember(GITHUB_TOKEN_SET, "boom", function(err, dbres) {
          assert.equal(dbres, 1);
          return done();
        });
      });
    });
    return it('/auth/github redirects to github.com', function(done) {
      return request(app).get('/auth/github?opts={"state": "foobar"}').expect(302).end(function(err, res) {
        expect(res.header['location']).to.be.equal("https://github.com/login/oauth/authorize" + ("?client_id=" + process.env.GITHUB_CLIENT_ID + "&state=foobar"));
        return done();
      });
    });
  });

  describe('KEYS - DEL, EXISTS', function() {
    resetdb();
    it('EXISTS returns 1 for existing key', function(done) {
      db.set('beans', 'pork');
      return request(app).get('/exists/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("1", done);
    });
    it('DEL returns 1', function(done) {
      return request(app).post('/del/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("1", done);
    });
    it('EXISTS now returns 0', function(done) {
      return request(app).get('/exists/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("0", done);
    });
    return it('DUMP returns serialized that can be restored', function(done) {
      db.hset('myhash', 'mykey', 'quux');
      return request(app).get('/dump/myhash').set({
        "access_token": "TESTTOKEN"
      }).expect(200).end(function(err, res) {

        /*
        console.log "RES!!!!!!!!!!!!!!!!!!"
        console.log res
        console.log res.text
        request(app)
          .post('/restore/differentkey?args=0')
          .set({"access_token": "TESTTOKEN"})
          .send(res.text)
          .expect(200, done)
         */
        return done();
      });
    });
  });

  describe('KEYS - EXPIRE, PEXPIRE, PTTL', function() {
    resetdb();
    it('EXPIRE makes the PTTL work', function(done) {
      return db.set('mykey', 'somestring', function() {
        return request(app).post('/expire/mykey').set({
          "access_token": "TESTTOKEN"
        }).send("50").expect(200).end(function(err, res) {
          return request(app).get('/pttl/mykey').set({
            "access_token": "TESTTOKEN"
          }).expect(200).end(function(err, res) {
            var ttl;
            ttl = parseInt(res.text);
            expect(ttl).most(50000).least(49990);
            return done();
          });
        });
      });
    });
    return it('PEXPIRE makes correct PTTL', function(done) {
      return db.set('mykey', 'somestring', function() {
        return request(app).post('/pexpire/mykey').set({
          "access_token": "TESTTOKEN"
        }).send("500").expect(200).end(function(err, res) {
          return request(app).get('/pttl/mykey').set({
            "access_token": "TESTTOKEN"
          }).expect(200).end(function(err, res) {
            var ttl;
            ttl = parseInt(res.text);
            expect(ttl).most(500).least(490);
            return done();
          });
        });
      });
    });
  });

  describe('KEYS - INCR, DECR', function(done) {
    resetdb();
    return it('INCR empty key returns 1, DECR -> 0', function() {
      return request(app).post('/incr/somekey').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("1").end(function(err, res) {
        return request(app).post('/decr/somekey').set({
          "access_token": "TESTTOKEN"
        }).expect(200).expect("0", done);
      });
    });
  });

  describe('GET, SET, APPEND', function() {
    resetdb();
    it('GET returns an empty response', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("", done);
    });
    it('SET returns OK', function(done) {
      return request(app).post('/set/foobar').set({
        "access_token": "TESTTOKEN"
      }).send('baz').expect(200).expect("OK", done);
    });
    it('GET returns the stored value', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("baz", done);
    });
    it('APPEND returns 7 (length)', function(done) {
      return request(app).post('/append/foobar').set({
        "access_token": "TESTTOKEN"
      }).send('quux').expect("7", done);
    });
    return it('GET returns the appended value', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect("bazquux", done);
    });
  });

  describe('LPUSH, LRANGE', function() {
    resetdb();
    it('LRANGE needs args', function(done) {
      return request(app).get('/lrange/baz').set({
        "access_token": "TESTTOKEN"
      }).expect(500).expect(/wrong number of arguments/, done);
    });
    it('LRANGE returns empty list', function(done) {
      return request(app).get('/lrange/baz?args=0,-1').set({
        "access_token": "TESTTOKEN"
      }).expect('[]', done);
    });
    it('LPUSH returns 1', function(done) {
      return request(app).post('/lpush/baz').set({
        "access_token": "TESTTOKEN"
      }).send('rawness').expect('1', done);
    });
    return it('LRANGE returns the value', function(done) {
      return request(app).get('/lrange/baz?args=0,1').set({
        "access_token": "TESTTOKEN"
      }).expect('["rawness"]', done);
    });
  });

  describe('HGET, HSET, HLEN, HKEYS', function() {
    resetdb();
    it("HSET sets field's value", function(done) {
      return request(app).post('/hset/foo?args=bar').set({
        "access_token": "TESTTOKEN"
      }).send('baz').expect(200).expect('1', done);
    });
    it('HGET returns value', function(done) {
      return request(app).get('/hget/foo?args=bar').set({
        "access_token": "TESTTOKEN"
      }).expect('baz', done);
    });
    it('HLEN returns length', function(done) {
      return request(app).get('/hlen/foo').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect('1', done);
    });
    return it('HKEYS returns keys', function(done) {
      return request(app).get('/hkeys/foo').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect('["bar"]', done);
    });
  });

}).call(this);
