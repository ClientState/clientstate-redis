// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter, GITHUB_AUTH_HASH, GITHUB_TOKEN_SET, MockGithub, MockResponse, app, assert, db, httpMocks, request, resetdb, skyl, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  request = require('supertest');

  httpMocks = require('node-mocks-http');

  EventEmitter = require('events').EventEmitter;

  assert = require('assert');

  app = require('../app').app;

  db = require('../db').db;

  _ref = require('../constants'), GITHUB_TOKEN_SET = _ref.GITHUB_TOKEN_SET, GITHUB_AUTH_HASH = _ref.GITHUB_AUTH_HASH;

  skyl = {
    "login": "skyl",
    "id": 61438
  };

  MockResponse = (function(_super) {
    __extends(MockResponse, _super);

    function MockResponse(statusCode, body) {
      var self;
      this.statusCode = statusCode;
      self = this;
      setTimeout(function() {
        self.emit("data", body);
        return self.emit("end");
      }, 1);
    }

    return MockResponse;

  })(EventEmitter);

  MockGithub = (function(_super) {
    __extends(MockGithub, _super);

    MockGithub.prototype.eventListeners = {};

    MockGithub.prototype.emitCounts = {};

    function MockGithub() {
      this.requestToken = __bind(this.requestToken, this);
      this.on('requestToken', this.requestToken);
      this.on('receiveAccessToken', this.receiveAccessToken);
    }

    MockGithub.prototype.requestToken = function(req, res, cb) {
      var _base;
      if ((_base = this.emitCounts)['requestToken'] == null) {
        _base['requestToken'] = 0;
      }
      this.emitCounts['requestToken']++;
      return cb(new MockResponse(200, '{"access_token": "boom"}'));
    };

    MockGithub.prototype.receiveAccessToken = function(access_token, cb) {
      var _base;
      if ((_base = this.emitCounts)['receiveAccessToken'] == null) {
        _base['receiveAccessToken'] = 0;
      }
      this.emitCounts['receiveAccessToken']++;
      db.sadd(GITHUB_TOKEN_SET, access_token);
      db.hset(GITHUB_AUTH_HASH, access_token, JSON.stringify(skyl));
      return cb();
    };

    return MockGithub;

  })(EventEmitter);

  global.gh = new MockGithub;

  resetdb = function() {
    db.flushall();
    db.sadd(GITHUB_TOKEN_SET, "TESTTOKEN");
    return db.hset(GITHUB_AUTH_HASH, "TESTTOKEN", JSON.stringify(skyl));
  };

  describe('GITHUB AUTH', function() {
    resetdb();
    it('returns invalid with no token', function(done) {
      return request(app).get('/get/foobar').expect(/Invalid/).expect(403, done);
    });
    it('does not allow restricted keys', function(done) {
      request(app).get("/get/" + GITHUB_TOKEN_SET + "/").set({
        "access_token": "TESTTOKEN"
      }).expect(403);
      return request(app).get("/get/" + GITHUB_AUTH_HASH + "/").set({
        "access_token": "TESTTOKEN"
      }).expect(403, done);
    });
    it('rejects invalid token', function(done) {
      return request(app).get("/get/foobar").set({
        "access_token": "NOWAYTHISISAREALTOKEN"
      }).expect(403, done);
    });
    it('reject invalid token in querystring', function(done) {
      return request(app).get("/get/foobar?access_token=WRONGE").expect(403, done);
    });
    it('allows call with token in querystring', function(done) {
      return request(app).get("/get/baz?access_token=TESTTOKEN").expect(200, done);
    });
    return it('emits events when /auth_callback is called', function(done) {
      return request(app).get("/auth_callback?code=thisisgreat").expect(200).expect("OK").end(function() {
        assert.equal(gh.emitCounts["requestToken"], 1);
        assert.equal(gh.emitCounts["receiveAccessToken"], 1);
        return db.sismember(GITHUB_TOKEN_SET, "boom", function(err, dbres) {
          assert.equal(dbres, 1);
          return done();
        });
      });
    });
  });

  describe('KEYS - DEL, EXISTS, DUMP', function() {
    resetdb();
    it('EXISTS returns 1 for existing key', function(done) {
      db.set('beans', 'pork');
      return request(app).get('/exists/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("1", done);
    });
    it('DEL returns true', function(done) {
      return request(app).post('/del/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("true", done);
    });
    it('EXISTS now returns 0', function(done) {
      return request(app).get('/exists/beans').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("0", done);
    });
    return it('DUMP returns serialized hash', function(done) {
      db.hset('myhash', 'mykey', 'quux');
      return request(app).get('/dump/myhash').set({
        "access_token": "TESTTOKEN"
      }).expect(200, done);
    });
  });

  describe('GET, SET, APPEND', function() {
    resetdb();
    it('GET returns an empty response', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("", done);
    });
    it('SET returns true', function(done) {
      return request(app).post('/set/foobar').set({
        "access_token": "TESTTOKEN"
      }).send('baz').expect(200).expect("true", done);
    });
    it('GET returns the stored value', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect("baz", done);
    });
    it('APPEND returns true', function(done) {
      return request(app).post('/append/foobar').set({
        "access_token": "TESTTOKEN"
      }).send('quux').expect("true", done);
    });
    return it('GET returns the appended value', function(done) {
      return request(app).get('/get/foobar').set({
        "access_token": "TESTTOKEN"
      }).expect("bazquux", done);
    });
  });

  describe('LPUSH, LRANGE', function() {
    resetdb();
    it('LRANGE needs args', function(done) {
      return request(app).get('/lrange/baz').set({
        "access_token": "TESTTOKEN"
      }).expect(500).expect(/wrong number of arguments/, done);
    });
    it('LRANGE returns empty list', function(done) {
      return request(app).get('/lrange/baz?args=0,-1').set({
        "access_token": "TESTTOKEN"
      }).expect('[]', done);
    });
    it('LPUSH returns true', function(done) {
      return request(app).post('/lpush/baz').set({
        "access_token": "TESTTOKEN"
      }).send('rawness').expect('true', done);
    });
    return it('LRANGE returns the value', function(done) {
      return request(app).get('/lrange/baz?args=0,1').set({
        "access_token": "TESTTOKEN"
      }).expect('["rawness"]', done);
    });
  });

  describe('HGET, HSET, HLEN, HKEYS', function() {
    resetdb();
    it("HSET sets field's value", function(done) {
      return request(app).post('/hset/foo?field=bar').set({
        "access_token": "TESTTOKEN"
      }).send('baz').expect(200).expect('true', done);
    });
    it('HGET returns value', function(done) {
      return request(app).get('/hget/foo?field=bar').set({
        "access_token": "TESTTOKEN"
      }).expect('baz', done);
    });
    it('HLEN returns length', function(done) {
      return request(app).get('/hlen/foo').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect('1', done);
    });
    return it('HKEYS returns keys', function(done) {
      return request(app).get('/hkeys/foo').set({
        "access_token": "TESTTOKEN"
      }).expect(200).expect('["bar"]', done);
    });
  });

}).call(this);
